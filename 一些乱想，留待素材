REACT最为核心的内容：在思路上,提供了对象化展现元素的思路；在开发的支持上，提供了基本的抽象模式和渲染机制；
	
	1、更为精细化的DOM操作颇为优秀；
	2、对象化的思路颇为符合人们对于事物的认识过程，也是未来发展的方向。

	但其依然有着颇为无奈的一些缺陷。
		1、混合式的编程方式，不仅仅是开发体验上的混乱了；而是在大规模的应用开发的时候，编写过程和进行装饰的分工变得混乱。还没有将脚本化的应用程序抽象到一个真正应用的高度，将脚本化应用的开发过程和角色细分出来。至少，简单的，装饰和动作，是完全可以分开的内容。。。。。。。。
		2、还缺乏一些必要的组件。组件的必要性，不仅仅是可以拿来用，减少一些工作量；更为重要的意义在于对应用架构的搭建和封装、以及普通的逻辑开发的指导和借鉴作用，不至于让产出的思路过份偏离于REACT的思路。榜样的力量是无穷的。简单实用的几个例子，远比长篇大论的说明文档来得更有效果。
	
	产品、工程的构建，依然需要应用架构师在此基础上进行有效的抽象动作；基础的开发人员也许会把事情搞得一塌糊涂。
	
有关应用构建的思路：
	REACT提供的基于状态流的设计思路，在构建之初，预先总结和考虑你的状态集合；应用的运行情况，在内核看来，是由一个又一个的状态转换，来形成应用的运转（他们认为，这样可以更好地回溯与预测）。
	1、前端框架的运行环境，导致了其主体数据并不是有应用自身存储，而是由远端的服务器来存储；在多人协作系统中，这样的状态也许就无法回溯，或者，即使应用本身的状态回溯正确了，但实际的数据状态已经发生变化。
	2、脚本语言的动态特性，更有趣的地方在于构建动态的结果，永远都是新的状态；可惜，这里有些不好玩了。另外，尤其浏览器端的脚本执行，往往是先传输代码，再执行代码；更为有趣的，可能在代码执行的过程中，再获取代码片段，再执行，在得到新的结果。我觉得，这恐怕就很难用状态流的方式进行设计了吧。脚本语言的代码本身，也是数据的一种，那么，请把它当作动态的情况来看吧。
	
回到正常的前端框架设计的思考上来吧。
	1、前端程序，作为人机交互的接口，其最核心也最为有效的机制应该是对于用户输入的捕获、理解与响应上来。（前文中，REACT所推崇的状态流转的方式，目标在于对状态的回溯和预测上。其实，输入是无法预测的，而历史的回顾，也只有在具有一定的业务含义的时候，才会有价值。）前端框架的目标，更应该在于对每一种不同的用户输入，进行分工理解，和响应。一个前端组件，包含他的输出（UI展示）、对于输入的理解、和响应；更为丰富一些的，包含的数据和相应的处理逻辑（更新逻辑等）；再为高阶一些的，同时还包含它的版本的更新（嵌入式代码的植入，这往往被认为是不安全的，但其实是能够提供更为优秀的效果的，也可能可以催生更为丰富的部署模型）（区块链是否会有些参考意义来保证安全。）
	2、基于开发工作更为细致的总结分类，将实际的产品工程开发工作能够有效地，更为专业的分类隔离。这样，我们的工作可以在不同层面上更为有效地协作，即使是相同的人来做事情，工作也更为有条理。？？？
	
	3、脚本化代码最好能够动态加载，计算能够更为多样、也能够更有趣地分发。
	
	4、requires、ECMAScript6的糖，等等之类的模块化的思路，在开发能够使代码更为有条理，同时保护全局句柄。不过，我这里觉得，全局句柄的变化，在可控范围内，是否可以去拥抱它们的变化。
	
	
	
	移动应用或者类CS的嵌入式功能界面；
状态机体系，通过状态机体系进行逻辑降解，简化了逻辑思考，但是，同样也局限了其架构建设的规模；

开发：
	通过状态机的逻辑降解，原本需要完成考虑的事件捕获、逻辑运算、数据变化、以及后续DOM休整的完整逻辑，被切分成：响应运算输入状态机、依据状态机的渲染逻辑。形成一套思考和设计的懒人模式；
DOM化的开发：
	对象化逻辑组织，和结构化的XML组织形式的混合。纯粹的表象工程！全部推荐组合模式构建，缺乏对象化、对象层级化的设计，就是致使了很多通用性质的逻辑变得很难共享，切面性质的整体把控变得更难。这是目前开发中，工作量、工作成本难以降低的核心原因。
	less，json化去编写的样式文件。看起来简单了。
		1、由于业务逻辑的开发，就是DOM及其绑定逻辑的开发，直接让开发者接触实际DOM，所以样式的设计引用全部落在了开发者手中（而且是业务逻辑的开发者）。作为工程的整体控制能力降低很多。逻辑开发人员对于DOM样式的设计并不专业，他们倒是可以做到看起来很像。可以，实际上style控制展示，是基于DOM层级结构的整体控制体系，它的编写和设计思路绝对不是简单的一个对象一个类。。。。
		2、另外一点隐患，对于一页化应用工程而言：混乱，样式计算的混乱，早晚会出现。

以上这些开发体验的构建，也算是老派架构思路的一个不错的实现，当作算法思路来看也不错。
这些开发体验的设计，旨在加强单兵作战能力，独立的一个程序员可以完成所有功能，（当然，上手难度上要高出许多 。）所有工作杂糅在一起。如果没有另外的全局架构设计，或者，对普通程序员屏蔽掉这些特性，团队就会被分隔成一个一个小作坊。这好像并不是一个很好的征兆。
git
git
分类，切分层次，让各个层次的工作单一化、标准化；层次之间。。。。


对象化的不足


	
	
