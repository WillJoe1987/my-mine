
       框架本身是一套可运行的封闭程序，开发上的代码在这套框架下，变得静态化，结构化，片段化。以此形成极简化的开发体验。
	可运行的新的体验需求，不得不依赖于框架自身的研发和更新，以此，逐步实现的需求和创新的收集；同时框架本身的更新就具有了以下特征：1、直接服务于终端用户；2、具备该框架下的所有项目的通用性和可推广性；
	大量运用js代码的动态加载；能够有效地实现按需加载，这里的需，都是由终端用户操作得出，换句话说，就是按需按的是客户需求，而不是传统意义上的程序员所认为的需。（js内存收集的设计、http链接加载的设计）
	其实，如果换一个角度，脚本语言本身，代码和数据的界限本身就已经模糊不清了。莫不如，就把代码本身当作一种数据来看待，大约思路上就开阔了很多。大可不必如此大费周折，做出一套的编译原理的实现，而且，最后反而降低了脚本语言的动态特性。




1、ES6标准糖分过高，甜的发腻；部分特性容易引起歧义；足以引发变革性的架构设计支持不多（如SYMBOL）；各种特性在不同环境里的支持性不一，细节太多，需要慎重使用；
	究其原因，大概标准制定者与实际的引擎实现者不同吧；
2、脚手架的一些工具特性，如jsx的模版化的语言、webpack的预处理“编译”，未必是一个很好的方法；他提高了一些工程管理的效率；但让所编写和所运行的内容，成为了完全同的两种东西，有点不很符合脚本语言本身的精神；兼容性的调整完全取决于工具，开发者的可控范围更小；对于环境和实际的运行原理等技术点的屏蔽性更高，（我觉得很扯淡。）
3、全部的组合模式？看起来所有的界面确实是组合起来的。
4、架构的核心思想是分类；框架的核心手段是搭积木；如果积木块的分类没有做好的时候，积木搭出来，也许就很容易倒了。
5、模块化，截至目前为止，所见识到的主要作用：1、保护全局句柄；2、保护类型私有句柄。这个理论，主要是基于javascript在其原本的安全模型上的缺陷。javascript本身是无法修正的。所以，到目前为止，requires通过制作一个简单的转义性质的编译器来实现；而EcmaScript6则通过定义了几个关键字来处理(包括变量作用域，和类型的化代码的引用）


关注点：
1、Symbol；
2、yield，生成器函数；






9月10日应完成：1、用户管理代码提交：：：

未完成原因===>
	1、connect函数的变化：connect函数将子域状态机绑定到指定状态机，并形成一个外壳程序保护住了子域的方法及状态（应该是代码入侵实现的），这样，子域内部的状态机依然可用，但是只能够在模块内部可见，模块外部则无法看见。对于模块外部的对象而言，则只能看到其壳对象，以及在其所绑定的状态机中所引用的状态；
	复杂的层级化对象和可枚举的大量对象的状态域如何设计。
	这让原本很难寻找规律的用户接口（UI）设计，变成了简单的状态机的设计与实现，看起来，简化了很多东西。
	捕捉
	2、代码入侵的现象随处可见，为这个知识体系形成一套不错的屏障。授柄于人。
	
1、毛坯而已；
2、采用组合化的方式编程，而不是采用面向对象的思路。不同层次的内容版本滚动会出现难以维护的问题；没有对象层级结构架构师会比较难以进行代码的控制；
3、样式代码不应该是业务代码编写的必须；
4、状态机的方式控制动作是比较经典的设计理论；但是用于前端设计，并不是很好的实践，特别是多人操作类型的系统；
5、剔除了脚本语言动态加载的特性。这里的按需加载只是考虑程序运行的需要；而不是考虑实际终端用户的需要。对于脚本程序而言，代码是一种数据，数据的加载是由终端用户选择，那么，针对数据呈现与操作的代码，也应该是由用户选择加载的。





