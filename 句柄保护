很多原则都被归纳到句柄的保护上来，比如：
	模块化，import关键字，尤其像类似后端js服务中，所提供个了类编译体系的import关键字；
	Imxxxxxx.js多 提供了不可更改特性，其实也是出于对句柄的保护，而不是应用。其实现原理也很简单，将数据对象或者数据类型中的各种操作delete掉，再包上自己的代理对象。呵，重得过分了点，而且，它们也依然无法保证，外泄句柄对于对象实际内容的操作，我们只需要在更长的调用链里保存下原始句柄，一样可以操作其内容，且会被这个小框架接收，且对象相等的判定依然可以生效。
	react-redux体系中，状态机的不可变更性，以及各类代理、调用链的小把戏，做来做去也是为了保护js中过分灵活的句柄对象判定原则。当然，状态机体系本身，也用来做开发意义上的句柄内容监听，推动后续动作，以此，将开发者的动作设计切割开来，作为一套开发体验存在。可惜的一点是，为了维护状态机的不可变性，无论异步，或者同步的操作中，不得不以回调，或者匿名函数作为来回传递的内容，无形中，代码的层次结构就变得非常复杂。在缺乏应用框架的情况下，状态机，会像线团一样，被我们的开发者小猫绕得一团糟。
