<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:12.0pt;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
h1
	{mso-style-link:"标题 1 Char";
	margin-top:11.25pt;
	margin-right:0cm;
	margin-bottom:11.25pt;
	margin-left:21.0pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:-21.0pt;
	line-height:28.9pt;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Calibri","sans-serif";}
h2
	{mso-style-link:"标题 2 Char";
	margin-top:7.5pt;
	margin-right:0cm;
	margin-bottom:7.5pt;
	margin-left:21.0pt;
	text-indent:-21.0pt;
	line-height:20.8pt;
	page-break-after:avoid;
	font-size:15.0pt;
	font-family:"Cambria","serif";}
h3
	{mso-style-link:"标题 3 Char";
	margin-top:13.5pt;
	margin-right:0cm;
	margin-bottom:3.75pt;
	margin-left:21.0pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:-21.0pt;
	line-height:20.8pt;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Calibri","sans-serif";}
h4
	{mso-style-link:"标题 4 Char";
	margin-top:14.0pt;
	margin-right:0cm;
	margin-bottom:14.5pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:18.8pt;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Cambria","serif";}
p.MsoCommentText, li.MsoCommentText, div.MsoCommentText
	{mso-style-link:"批注文字 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"标题 Char";
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:16.0pt;
	font-family:"Cambria","serif";
	font-weight:bold;}
p.MsoDate, li.MsoDate, div.MsoDate
	{mso-style-link:"日期 Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:5.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:12.0pt;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoCommentSubject, li.MsoCommentSubject, div.MsoCommentSubject
	{mso-style-link:"批注主题 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";
	font-weight:bold;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"批注框文本 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:12.0pt;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	line-height:12.0pt;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
span.Char
	{mso-style-name:"批注文字 Char";
	mso-style-link:批注文字;}
span.Char0
	{mso-style-name:"批注主题 Char";
	mso-style-link:批注主题;
	font-weight:bold;}
span.Char1
	{mso-style-name:"批注框文本 Char";
	mso-style-link:批注框文本;}
span.Char2
	{mso-style-name:"标题 Char";
	mso-style-link:标题;
	font-family:"Cambria","serif";
	font-weight:bold;}
span.Char3
	{mso-style-name:"日期 Char";
	mso-style-link:日期;}
span.1Char
	{mso-style-name:"标题 1 Char";
	mso-style-link:"标题 1";
	font-weight:bold;}
span.2Char
	{mso-style-name:"标题 2 Char";
	mso-style-link:"标题 2";
	font-family:"Cambria","serif";
	font-weight:bold;}
span.3Char
	{mso-style-name:"标题 3 Char";
	mso-style-link:"标题 3";
	font-weight:bold;}
p.TIP, li.TIP, div.TIP
	{mso-style-name:TIP;
	mso-style-link:"TIP Char";
	margin-top:7.5pt;
	margin-right:0cm;
	margin-bottom:7.5pt;
	margin-left:48.6pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:22.05pt;
	line-height:12.0pt;
	font-size:10.5pt;
	font-family:"Calibri","sans-serif";
	font-style:italic;}
span.4Char
	{mso-style-name:"标题 4 Char";
	mso-style-link:"标题 4";
	font-family:"Cambria","serif";
	font-weight:bold;}
span.TIPChar
	{mso-style-name:"TIP Char";
	mso-style-link:TIP;
	font-style:italic;}
.MsoChpDefault
	{font-family:"Calibri","sans-serif";}
 /* Page Definitions */
 @page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=ZH-CN link=blue vlink=purple style='text-justify-trim:punctuation'>

<div class=WordSection1 style='layout-grid:15.6pt'>

<p class=MsoTitle><span style='font-family:宋体'>前端框架的一些介绍和思路</span></p>

<p class=MsoNormal align=right style='text-align:right'><span lang=EN-US>2016-03-09</span></p>

<p class=MsoNormal align=right style='text-align:right'><span style='font-family:
宋体'>焦向波</span></p>

<h1 style='margin-left:28.1pt;text-indent:-28.1pt'><span lang=EN-US>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>WLJ</span><span style='font-family:宋体'>框架现状介绍</span></h1>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>a)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>背景</span></h2>

<p class=MsoNormal style='margin-left:24.25pt;text-indent:24.25pt'><span
lang=EN-US>CRM</span><span style='font-family:宋体'>前端框架的最初的构建，是为了降解之前裸用</span><span
lang=EN-US>Ext</span><span style='font-family:宋体'>框架时带来的一系列负面影响，如，门槛高、</span><span
lang=EN-US>BUG</span><span style='font-family:宋体'>率高、代码量大等问题；同时，期许于框架的重新构建，在之前的操作、</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>上，能做出一些突破。</span></p>

<p class=MsoNormal style='margin-left:24.25pt;text-indent:24.25pt'><span
style='font-family:宋体'>截止到目前为止，在两三年框架的发展过程中，形成一些思路。</span></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>b)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>运行原理</span></h2>

<p class=MsoNormal style='margin-left:49.55pt'><span style='font-family:宋体'>虚拟机式的代码运行机制</span></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>看</span></i><i><span
lang=EN-US style='font-size:10.5pt'>java</span></i><i><span style='font-size:
10.5pt;font-family:宋体'>的收获</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>在研发开发框架的过程中，我的</span></i><i><span lang=EN-US style='font-size:
10.5pt'>eclipse</span></i><i><span style='font-size:10.5pt;font-family:宋体'>恰好老是出问题。就翻阅参考资料，折腾</span></i><i><span
lang=EN-US style='font-size:10.5pt'>java</span></i><i><span style='font-size:
10.5pt;font-family:宋体'>虚拟机，看</span></i><i><span lang=EN-US style='font-size:
10.5pt'>java</span></i><i><span style='font-size:10.5pt;font-family:宋体'>代码执行原理之类的，倒是受了一些影响。</span></i></p>

<p class=MsoNormal style='margin-left:48.6pt;text-indent:24.25pt'><span
style='font-family:宋体'>针对普通开发人员的业务逻辑开发，</span><span lang=EN-US>WLJ</span><span
style='font-family:宋体'>框架将页面抽象成界面配置句柄和逻辑片段句柄，同时，以全局句柄的方式，给开发人员提供一些工具方法（</span><span
lang=EN-US>API</span><span style='font-family:宋体'>）。通过这些句柄，将框架运行与业务逻辑解耦。</span></p>

<p class=MsoNormal style='margin-left:48.6pt;text-indent:24.25pt'><span
style='font-family:宋体'>开发人员负责填充这些句柄；运行框架负责解释这些句柄；换言之，就是将业务描述，与技术运行解耦。</span></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>框架取舍</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>当然，这样直接采用全局句柄的方式进行逻辑与技术的解耦，存在一定的句柄冲突风险；同时，也进行了必要的取舍，放弃了完全的</span></i><i><span
lang=EN-US style='font-size:10.5pt'>ONEPAGE</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>模式进行，变得有点胖瘦客户端模式掺杂；但是，避免了命名空间系统的设计与管理，降低了内存管理与回收的难度。</span></i></p>

<p class=MsoNormal style='margin-left:48.6pt;text-indent:24.25pt'><span
style='font-family:宋体'>类似</span><span lang=EN-US>java</span><span
style='font-family:宋体'>虚拟机的运行过程，框架的运行是一套封闭的，自运行的逻辑模式。</span></p>

<p class=MsoNormal style='margin-left:48.6pt;text-indent:24.25pt'><span
style='font-family:宋体'>其运行方式为：</span></p>

<p class=MsoListParagraph style='margin-left:103.1pt;text-indent:-18.0pt'><span
lang=EN-US>1、</span><span style='font-family:宋体'>首先加载框架运行所必须的支撑文件，构建运行所需的体系；</span></p>

<p class=MsoListParagraph style='margin-left:103.1pt;text-indent:-18.0pt'><span
lang=EN-US>2、</span><span style='font-family:宋体'>根据菜单参数，加载业务代码；</span></p>

<p class=MsoListParagraph style='margin-left:103.1pt;text-indent:-18.0pt'><span
lang=EN-US>3、</span><span style='font-family:宋体'>根据代码引用，加载第三方类库；</span></p>

<p class=MsoListParagraph style='margin-left:103.1pt;text-indent:-18.0pt'><span
lang=EN-US>4、</span><span style='font-family:宋体'>检查业务代码句柄，排除必要的错误；</span></p>

<p class=MsoListParagraph style='margin-left:103.1pt;text-indent:-18.0pt'><span
lang=EN-US>5、</span><span style='font-family:宋体'>构建整体调度对象以及下辖的子对象，渲染界面，绑定事件等等操作（业务代码的载入至此完结，后续就是针对业务输入的响应了，完全由框架进行调配）；</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:103.1pt;text-indent:-18.0pt'><span
lang=EN-US>6、</span><span style='font-family:宋体'>根据用户输入，调用必要的事件逻辑片段。</span></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>首页框架</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>以上描述，为单个功能点内部的逻辑运行原理。而在开发框架之上，首页框架上同样伴随着整体的任务窗口管理、瓷贴队列管理、版本管理等功能，这里不细述。</span></i></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>c)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>开发接口</span></h2>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>开发接口，在这里主要是指我们的句柄和</span><span lang=EN-US>API</span><span
style='font-family:宋体'>；但是，在有些情况下，某些全局配置、某些内部类暴露的方法、以及</span><span lang=EN-US>Ext</span><span
style='font-family:宋体'>的一些源生对象也会成为业务逻辑开发的部分。</span></p>

<p class=MsoNormal style='margin-left:24.25pt;text-indent:24.25pt'><span
style='font-family:宋体'>在开发接口的设计在这几年的更新中，逐步形成几个规则：</span></p>

<p class=MsoListParagraph style='margin-left:3.0cm;text-indent:-1.05pt'><span
lang=EN-US>1、<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><strong><span
style='font-family:宋体'>接口文件要独立、稳定</span></strong><span style='font-family:宋体'>。句柄接口不归属于框架，也不归属于业务。通过句柄名称的固化，形成独立的句柄对象；同时，无论在框架发生怎样的变化，句柄接口名称、结构、以及调用方式不发生变化。</span></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>句柄带来解耦，解耦带来好处</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>这个规范形成，不仅仅是为了框架与功能（技术与业务）的解耦。更重要的一点在于遵循这个规范，产品框架在版本发展的持续性，兼容性上能够得到有效的控制与保证。框架的滚动更新，独立的句柄可以有效地摒除往期框架版本下业务代码的兼容性影响。</span></i></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>看</span></i><i><span
lang=EN-US style='font-size:10.5pt'>C</span></i><i><span style='font-size:10.5pt;
font-family:宋体'>的收获</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>关于</span></i><i><span lang=EN-US style='font-size:10.5pt'>header</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>文件的形成，最初是学习了</span></i><i><span
lang=EN-US style='font-size:10.5pt'>C</span></i><i><span style='font-size:10.5pt;
font-family:宋体'>语言中的头文件的设计方式。</span></i><i><span lang=EN-US style='font-size:
10.5pt'>C</span></i><i><span style='font-size:10.5pt;font-family:宋体'>语言中，头文件申明结构、方法、以及各类变量句柄，当然，也并不强制变量一定在头文件中声明。我想这应该是</span></i><i><span
lang=EN-US style='font-size:10.5pt'>C</span></i><i><span style='font-size:10.5pt;
font-family:宋体'>语言为了解决大规模</span></i><i><span lang=EN-US style='font-size:10.5pt'>C</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>应用的协作问题，而给出的一个软性的协作方案。</span></i></p>

<p class=MsoListParagraph style='margin-left:3.0cm;text-indent:-1.05pt'><span
lang=EN-US>2、<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><strong><span
style='font-family:宋体'>分化脚本语言的动静态特征，降低门槛。</span></strong><span
style='font-family:宋体'>框架本身要多使用脚本语言的动态特性，多动态的构建对象，动态的绑定事件，动态调用过程；这样，就可以让业务开发人员尽量静态的定义变量、静态地编写函数、静态地调用</span><span
lang=EN-US>API</span><span style='font-family:宋体'>。</span></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>脚本的动态特性</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>脚本语言，一般语法规则简单，但调用极为灵活。其简单的安全模型，导致内存对象的动态特性极强，方法、过程的调用时机、顺序因素极为复杂；这些因素往往使开发人员的晕头转向。其代码的文本又是静态特性的，不需要经过编译链接，极容易将文本转化为代码以及内存对象。</span></i></p>

<p class=MsoListParagraph style='margin-left:3.0cm;text-indent:-1.05pt'><span
lang=EN-US>3、<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><strong><span
style='font-family:宋体'>接口结构的设计，要尽量使用简单变量，简单函数。</span></strong><span
style='font-family:宋体'>开发人员代码尽量降解到与业务相关的必要配置，而不需要关心执行过程，与触发时机。</span></p>

<p class=MsoListParagraph style='margin-left:3.0cm;text-indent:-1.05pt'><span
lang=EN-US>4、<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><strong><span
style='font-family:宋体'>结构化的全局配置对象。</span></strong><span style='font-family:
宋体'>通用的逻辑，抽象成全局配置对象，在所有功能点生效；全局配置对象只起到一个默认值的作用，不强制。开发人员可以在个性化的界面中订制配置。</span></p>

<p class=MsoListParagraph style='margin-left:3.0cm;text-indent:-1.05pt'><span
lang=EN-US>5、<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><strong><span
style='font-family:宋体'>分级过程化的补丁。</span></strong><span style='font-family:宋体'>框架中提供了几种级别的补丁文件。对于一些需要逻辑过程的项目组个性需求，要提供一些可以编写这些代码的地方，这些代码可能会覆盖一些框架逻辑，可能会提供一些全局逻辑；一些不具备添加到产品框架功能的个性需求，或者一些需要紧急响应的过渡性需求响应，也可以在这种补丁文件中添加。这种补丁文件只能由项目组架构师来修改，或者产品部定向发送o指定项目组。</span></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>前段框架的补丁</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>目前，</span></i><i><span lang=EN-US style='font-size:10.5pt'>CRM</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>产品的前端框架中，包含几个这样的补丁文件：</span></i><i><span
lang=EN-US style='font-size:10.5pt'>Crm-Ext-Extends-1.000-v1.0.js</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>、</span></i><i><span lang=EN-US
style='font-size:10.5pt'>Crm-Ext-Patch-1.000-v1.0.css</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>用于与底层支持库</span></i><i><span lang=EN-US
style='font-size:10.5pt'>EXT</span></i><i><span style='font-size:10.5pt;
font-family:宋体'>框架的一些逻辑修改、</span></i><i><span lang=EN-US style='font-size:10.5pt'>BUG</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>修复、以及底层功能、浏览器版本适配等，它的加载时机是</span></i><i><span
lang=EN-US style='font-size:10.5pt'>Ext</span></i><i><span style='font-size:
10.5pt;font-family:宋体'>加载之后，</span></i><i><span lang=EN-US style='font-size:
10.5pt'>WLJ</span></i><i><span style='font-size:10.5pt;font-family:宋体'>框架加载之前；</span></i><i><span
lang=EN-US style='font-size:10.5pt'>systemPatch.js</span></i><i><span
style='font-size:10.5pt;font-family:宋体'>用于</span></i><i><span lang=EN-US
style='font-size:10.5pt'>WLJ</span></i><i><span style='font-size:10.5pt;
font-family:宋体'>框架相关的一些逻辑覆盖等，它的加载时机是</span></i><i><span lang=EN-US
style='font-size:10.5pt'>WLJ</span></i><i><span style='font-size:10.5pt;
font-family:宋体'>框架代码加载之后，框架构建之前；</span></i><i><span lang=EN-US
style='font-size:10.5pt'>defaultPatches.js</span></i><i><span style='font-size:
10.5pt;font-family:宋体'>用于为业务逻辑代码添加一些通用默认逻辑，不强制覆盖，它的加载时机是框架构建之后，业务代码加载之前。</span></i></p>

<p class=MsoNormal style='margin-left:48.6pt;text-indent:24.25pt'><span
style='font-family:宋体'>另外，还有一些小的规范，如：</span><span lang=EN-US>6</span><span
style='font-family:宋体'>、功能性需求由框架来做，业务代码只负责需求描述，质量高、风险小；</span><span lang=EN-US>7</span><span
style='font-family:宋体'>、句柄接口的订制，顺序的安排，尽量与需求文档的格式靠近；</span><span lang=EN-US>8</span><span
style='font-family:宋体'>、补丁、更新等，尽量以文件为单元进行设计编写；</span><span lang=EN-US>9</span><span
style='font-family:宋体'>、提供一些框架外的实用功能，如日志</span><span lang=EN-US>API</span><span
style='font-family:宋体'>，日志控件等；</span><span lang=EN-US>10</span><span
style='font-family:宋体'>、配置信息不急于持久化，不急于存到数据库。</span></p>

<p class=MsoListParagraph style='margin-top:7.5pt;margin-right:0cm;margin-bottom:
7.5pt;margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-size:10.5pt;font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><i><span style='font-size:10.5pt;font-family:宋体'>代码文档化的尝试</span></i></p>

<p class=MsoNormal style='margin-top:7.5pt;margin-right:0cm;margin-bottom:7.5pt;
margin-left:48.6pt;text-indent:22.05pt'><i><span style='font-size:10.5pt;
font-family:宋体'>关于第七点，是代码文档化方面的一点尝试。</span></i><i><span lang=EN-US
style='font-size:10.5pt'>Crockford</span></i><i><span style='font-size:10.5pt;
font-family:宋体'>先生最早提出代码文档化的观点。他说大家写代码，变量名要取好，方法名要取好，注释要写好，要让别人能看懂。可惜的是，这只是一种提倡。</span></i><i><span
lang=EN-US style='font-size:10.5pt'>python</span></i><i><span style='font-size:
10.5pt;font-family:宋体'>做的好点，但也仅仅在代码排版上有些进步，而且，它自身也陷入了无限回调的泥潭，所做有限。</span></i><i><span
lang=EN-US style='font-size:10.5pt'>WLJ</span></i><i><span style='font-size:
10.5pt;font-family:宋体'>的开发框架中，最初的一些接口设计有些参考了咱们需求文档的写法。比如，先编写输入输出字段，然后增删改面板逐个描述；字段约束逐条编写；业务限制也是附在最后逐条编写。我总觉得，代码文档化这种大命题，可以在具体的业务框架中，通过框架的强制性，是能够有一些前进的。</span></i></p>

<p class=MsoNormal style='margin-left:48.6pt;text-indent:24.25pt'><span
style='font-family:宋体'>框架的设计，就是取舍；最难的也是取舍。说多了，就成哲学了。绍雷说，抓住痛点。痛点与前瞻相结合，就是取舍的准则。</span></p>

<h3 style='text-indent:-21.0pt'><span lang=EN-US>i.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>面向架构师的全局配置</span></h3>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>框架提供一个全局化的配置文件，该文件中定义了各类全局性的配置属性。一些无关于业务的默认值、开关定义在这里。同时，包含了界面上各级别右键菜单逻辑的定义，以及可扩展的前端数据类型配置。这个文件中的内容，可由项目组架构师角色的人员上线前统一配置修改。</span><span
lang=EN-US>Wlj-frame-function-app-cfg.js</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.3pt'><b><span
style='font-family:宋体'>参考附：配置及补丁文件</span></b></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>同时，在这些静态配置的基础上，框架同时还提供了</span><span lang=EN-US>systemPatches.js</span><span
style='font-family:宋体'>和</span><span lang=EN-US>defaultPatches.js</span><span
style='font-family:宋体'>文件，用于做一些动态的逻辑化的全局修改，前文已有介绍。这两个文件可由项目组架构师角色人员统一修改，或者由产品部协助修改下发。</span></p>

<h3 style='text-indent:-21.0pt'><span lang=EN-US>ii.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>面向视图的属性句柄</span></h3>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这一部分的开发接口，特指在</span><span lang=EN-US>Wlj-frame-function-header.js</span><span
style='font-family:宋体'>文件中所定义的，除</span><span lang=EN-US>listeners</span><span
style='font-family:宋体'>对象之外的全局句柄。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这一类句柄绝大部分是定义界面的属性。但是，与其他的</span><span lang=EN-US>js</span><span
style='font-family:宋体'>框架不同，他并不直接定义或者接触</span><span lang=EN-US>DOM</span><span
style='font-family:宋体'>文档，也不直接定义或者创建</span><span lang=EN-US>js</span><span
style='font-family:宋体'>组件对象。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.3pt'><b><span
style='font-family:宋体'>参考附：接口文件</span></b></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这些句柄更多的从较为业务化的方面，对业务需求进行描述。比如，从哪里查数据，页面用了哪些字段，有哪些面板，有多少条校验规则，引用了哪些数据字典，有什么按钮之类的。</span></p>

<h3 style='text-indent:-21.0pt'><span lang=EN-US>iii.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>面向响应的逻辑片段</span></h3>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这一部分开发接口，定义在</span><span lang=EN-US>header</span><span
style='font-family:宋体'>文件的</span><span lang=EN-US>listeners</span><span
style='font-family:宋体'>对象内。<b>参考附：接口文件</b></span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这一类句柄大部分用于对用户输入做出逻辑响应。用户的所有输入，包括键盘点击，鼠标悬浮、移动、点击、右键、拖动等等，都会由框架捕获，并根据事件的实际情况，选择调用不同的片段逻辑进行响应。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这一类句柄，同样是以全局模式定义，但是以</span><span lang=EN-US>function</span><span
style='font-family:宋体'>的形式编写。这些函数在被调用的时候，会自动接收到与该输入响应有关的、逻辑片段编写所必要的参数。</span></p>

<p class=TIP style='margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-family:Wingdings;font-style:normal'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>Javascript</span><span style='font-family:宋体'>的函数调用方式很多，我们只提供一种</span></p>

<p class=TIP><span lang=EN-US>Js</span><span style='font-family:宋体'>函数的调用方式很多，常常导致函数内部逻辑出现不必要的问题。函数既可以作为方法独立存在，也可以作为对象类存在；函数的调用，既可以直接调用，也可以通过对象句柄调用，也可以通过指定作用域的方式进行调用。这三种调用方式，使得内部逻辑的作用域不同，说简单点，就是</span><span
lang=EN-US>this</span><span style='font-family:宋体'>指针所指代的东西不同，这就很有可能让函数的执行出现不可预期的问题。所以，在框架中，将所有逻辑片段句柄的执行作用域统一定义为全局统一调度对象（</span><span
lang=EN-US>APP</span><span style='font-family:宋体'>对象）。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这一类句柄，被定义为</span><span lang=EN-US>listener</span><span
style='font-family:宋体'>，或者说“事件”。但是，它们并不是</span><span lang=EN-US>DOM</span><span
style='font-family:宋体'>事件，它们并不会接触</span><span lang=EN-US>DOM</span><span
style='font-family:宋体'>，也不会成为对象监听。这些事件，都是由框架逻辑运算触发。有可能是几个源生事件的组合，也有可能是几个源生监听的组合。它们是更为业务化的。比如，它们可以定义页面加载以后要不要先做一些事情；选择一行数据后，要不要做一些事情；打开了新增面板要不要做些什么；要提交数据，在这提交之前和之后，要不要自动做些什么。</span></p>

<h3 style='text-indent:-21.0pt'><span lang=EN-US>iv.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>全局</span><span lang=EN-US> API</span><span
style='font-family:宋体'>的调用</span></h3>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>API</span><span style='font-family:宋体'>系统，在</span><span lang=EN-US>WLJ</span><span
style='font-family:宋体'>框架中，特指在</span><span lang=EN-US>Wlj-frame-function-api.js</span><span
style='font-family:宋体'>文件中定义的</span><span lang=EN-US>API</span><span
style='font-family:宋体'>对象的所有键值。</span><span lang=EN-US>API</span><span
style='font-family:宋体'>可以简化逻辑片段的编写难度。<b>参考附：接口文件</b></span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这些</span><span lang=EN-US>API</span><span
style='font-family:宋体'>的调用域为</span><span lang=EN-US>window</span><span
style='font-family:宋体'>，也就是说，直接根据名字和参数说明调用就可以了。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这些</span><span lang=EN-US>API</span><span
style='font-family:宋体'>通常可以独立发动一些效果，或者返回必要的结果。这些</span><span lang=EN-US>API</span><span
style='font-family:宋体'>同样是比较业务化的，无关</span><span lang=EN-US>DOM</span><span
style='font-family:宋体'>，也无关</span><span lang=EN-US>window</span><span
style='font-family:宋体'>或者浏览器对象。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这些</span><span lang=EN-US>API</span><span
style='font-family:宋体'>作用域均为全局调度对象（</span><span lang=EN-US>APP</span><span
style='font-family:宋体'>对象），也就是说，都是在</span><span lang=EN-US>APP</span><span
style='font-family:宋体'>对象上定义。但是，独立的</span><span lang=EN-US>API</span><span
style='font-family:宋体'>对象上的键和值（</span><span lang=EN-US>true</span><span
style='font-family:宋体'>或者</span><span lang=EN-US>false</span><span
style='font-family:宋体'>）用来定义该</span><span lang=EN-US>API</span><span
style='font-family:宋体'>是否装载。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这些</span><span lang=EN-US>API</span><span
style='font-family:宋体'>可以直接调用，但是有一定的约束条件。由于这些</span><span lang=EN-US>API</span><span
style='font-family:宋体'>的实现均在</span><span lang=EN-US>APP</span><span
style='font-family:宋体'>对象上，所以必须在</span><span lang=EN-US>APP</span><span
style='font-family:宋体'>对象构建之后才能调用。或者，简单点说，就是只能在其他的方法体内调用，不能在代码中顺序调用。当然，也只有在编写逻辑片段的时候，才需要调用这些</span><span
lang=EN-US>API</span><span style='font-family:宋体'>。</span></p>

<h3 style='text-indent:-21.0pt'><span lang=EN-US>v.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>其他一些子系统</span></h3>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><b><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>i.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:宋体'>日志监控系统</span></b></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>框架中的日志控制台中，框架内部的日志主要围绕两块进行：</span></p>

<p class=MsoNormal style='margin-left:63.8pt;text-indent:21.0pt'><span
lang=EN-US>1</span><span style='font-family:宋体'>、代码加载时的代码检查日志</span></p>

<p class=MsoNormal style='margin-left:63.8pt;text-indent:21.0pt'><span
lang=EN-US>2</span><span style='font-family:宋体'>、事件响应时的逻辑片段调用日志</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>另外，开发人员在开发调试过程中，也可以调用日志</span><span lang=EN-US>API</span><span
style='font-family:宋体'>，在控制台中打印日志代码。</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><b><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>ii.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:宋体'>异常捕获系统</span></b></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>异常捕获后，如果控制台打开的情况下，会在控制台中打印</span><span lang=EN-US>js</span><span
style='font-family:宋体'>错误信息。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>目前，主要捕获的异常信息包括：</span></p>

<p class=MsoNormal style='margin-left:63.8pt;text-indent:21.0pt'><span
lang=EN-US>1</span><span style='font-family:宋体'>、逻辑片段句柄中抛出的异常；</span></p>

<p class=MsoNormal style='margin-left:63.8pt;text-indent:21.0pt'><span
lang=EN-US>2</span><span style='font-family:宋体'>、界面配置句柄中部分需要编写的函数，如字段校验，字段联动等。</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><b><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>iii.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:宋体'>插件系统</span></b></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>界面加载完毕之后，会自动启动插件系统。插件文件中定义了插件编写接口。目前，插件系统带有查询方案保存插件和数据缩略图插件。</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><b><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>iv.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:宋体'>设计预览系统</span></b></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>设计及预览系统包括界面设计功能，和预览系统。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>界面设计功能中，可以完成对界面要素句柄的设计操作和代码的自动生成；设计功能待完善。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>预览界面可以在新的窗口中直接预览设计的界面，并在代码控制台直接动态编写代码，或者动态绑定事件句柄。</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><b><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>v.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:宋体'>测试加载系统（初版不甚满意，尚在完善）</span></b></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>测试系统目前有了自动测试的初步探索，但是，对于测试用例的编写和积累方案尚未认定。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>主要问题也是集中在取舍。用例跟着代码版本走，比较便于管理和维护，但是这些用例会让产品工程变得臃肿；如果用例单独作为文档管理，不便于管理维护和积累。</span></p>

<h1 style='margin-left:28.1pt;text-indent:-28.1pt'><span lang=EN-US>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>底层框架适配细则分析</span></h1>

<h2><span lang=EN-US>a)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>ExtJs</span><span style='font-family:宋体'>框架的使用现状</span></h2>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>WLJ</span><span style='font-family:宋体'>框架以</span><span lang=EN-US>ExtJs</span><span
style='font-family:宋体'>为底层工具和类库来组织的。但是，</span><span lang=EN-US>WLJ</span><span
style='font-family:宋体'>的整体运行机制则独立调用与实现。</span></p>

<p class=TIP style='margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-family:Wingdings;font-style:normal'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>Ext</span><span style='font-family:宋体'>的一点介绍</span></p>

<p class=TIP><span style='font-family:宋体'>关于</span><span lang=EN-US>ExtJs</span><span
style='font-family:宋体'>，通常人们使用这个框架，比较关注的就它提供的丰富的</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>组件，当然，也有人诟病核心库太大。这些都对。</span></p>

<p class=TIP><span style='font-family:宋体'>不过，我还是觉得这玩意儿真算是天才狂想式的作品，以至于我看到《架构师》杂志中一篇评论</span><span
lang=EN-US>js</span><span style='font-family:宋体'>框架的文章中，不得不将</span><span
lang=EN-US>ExtJs</span><span style='font-family:宋体'>单独作为一个分类，因为当前主流的分类都不合适。</span></p>

<p class=TIP><span style='font-family:宋体'>主流的</span><span lang=EN-US>js</span><span
style='font-family:宋体'>框架（或者说库），一般有以下几个方面的功能：</span><span lang=EN-US>1</span><span
style='font-family:宋体'>、基本的</span><span lang=EN-US>DOM</span><span
style='font-family:宋体'>操作工具；</span><span lang=EN-US>2</span><span
style='font-family:宋体'>、事件处理工具；</span><span lang=EN-US>3</span><span
style='font-family:宋体'>、</span><span lang=EN-US>Ajax</span><span
style='font-family:宋体'>的数据交互工具。随着</span><span lang=EN-US>javascript</span><span
style='font-family:宋体'>的应用发展，逐步出现了将以上功能对象化的封装，将常用的列表、表格封装为对象；再后来，</span><span
lang=EN-US>WEB</span><span style='font-family:宋体'>架构师开始想着把</span><span
lang=EN-US>WEB</span><span style='font-family:宋体'>工程的传统的框架思路搬到</span><span
lang=EN-US>javascript</span><span style='font-family:宋体'>框架上来，（在我看来，这些人，应该是在互联网大规模点阵化架构应用逐步丰富起来时，落伍的一批架构师。）</span><span
lang=EN-US>MVC</span><span style='font-family:宋体'>，或者</span><span lang=EN-US>MXXC</span><span
style='font-family:宋体'>之类的。我觉得这并不是最好的出路，脚本语言的动态特性的灵活运用，匿名函数，匿名对象的应用，才是其未来的出路。这并不是本文的重点。</span></p>

<p class=TIP><span style='font-family:宋体'>关于</span><span lang=EN-US>ExtJs</span><span
style='font-family:宋体'>，除了具备以上的几点的基础工具和类库外，它提供了一些颇为有效的特性，值得思考。有些在</span><span
lang=EN-US>WLJ</span><span style='font-family:宋体'>框架中，有颇多应用。</span></p>

<p class=TIP><span lang=EN-US>ExtJs</span><span style='font-family:宋体'>从</span><span
lang=EN-US>JAVA</span><span style='font-family:宋体'>基础语法和</span><span
lang=EN-US>JAVA</span><span style='font-family:宋体'>设计模式中借鉴颇多。所有对象从</span><span
lang=EN-US>Observable</span><span style='font-family:宋体'>对象逐层派生，其间很多面向对象的设计模式得到应用，单态、工厂、观察者、门面之类的，以及匿名对象，向上转型等。</span></p>

<p class=TIP><span style='font-family:宋体'>所有的</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>组件和控制组件，在逐步派生的过程中，形成固定的、软性的派生语法，让他的实际可用组件变为无限。</span></p>

<p class=TIP><span lang=EN-US>ExtJs</span><span style='font-family:宋体'>对</span><span
lang=EN-US>JS</span><span style='font-family:宋体'>源生类对象做了一些强，尤其</span><span
lang=EN-US>Function</span><span style='font-family:宋体'>对象的增强，提供了足够模拟线程和切面的方法。</span></p>

<p class=TIP><span style='font-family:宋体'>提供了颇多专门针对于数据结构的运算工具；</span></p>

<p class=TIP><span style='font-family:宋体'>提供了一个</span><span lang=EN-US>MixedCollection</span><span
style='font-family:宋体'>的数据结构。该数据结构等同于</span><span lang=EN-US>List</span><span
style='font-family:宋体'>和</span><span lang=EN-US>Map</span><span
style='font-family:宋体'>的结合，运用灵活，效率颇高。在</span><span lang=EN-US>WLJ</span><span
style='font-family:宋体'>框架中使用颇多。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>这里的主要是指框架中使用到的内容。</span></p>

<p class=MsoListParagraph style='margin-left:63.0pt;text-indent:-63.0pt'><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>ii.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Ext UI</span><span style='font-family:宋体'>对象的引用：主要包括：表单、列表、布局、动画、拖动、菜单、窗口、各类输入框、按钮、树形面板等对象。这些对象绝大多数是由框架内部自行控制，由框架自行控制构建渲染；</span></p>

<p class=MsoListParagraph style='margin-left:63.0pt;text-indent:-63.0pt'><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>iii.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span lang=EN-US>Ext </span><span style='font-family:宋体'>控制对象引用：数据源对象、</span><span
lang=EN-US>Ajax</span><span style='font-family:宋体'>对象，</span><span lang=EN-US>MixedCollection</span><span
style='font-family:宋体'>对象；这些在框架封装初始，也基本由框架控制代劳了；</span></p>

<p class=MsoListParagraph style='margin-left:63.0pt;text-indent:-63.0pt'><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>iv.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>其他，包括各类</span><span lang=EN-US>DOM</span><span
style='font-family:宋体'>增强</span><span lang=EN-US>API</span><span
style='font-family:宋体'>，事件绑定机制，命名空间系统、派生系统；此类功能也大都由框架使用。</span></p>

<p class=MsoListParagraph style='margin-left:63.0pt;text-indent:-63.0pt'><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>v.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>各条线前端代码中，有大量使用</span><span
lang=EN-US>Ext</span><span style='font-family:宋体'>派生的公共组建，各类放大镜、上传下载导入导出等等功能。</span></p>

<p class=MsoListParagraph style='margin-left:63.0pt;text-indent:-63.0pt'><span
lang=EN-US><span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>vi.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>部分业务逻辑代码中，由于业务操作较为复杂，开发人员采用源生的</span><span
lang=EN-US>Ext</span><span style='font-family:宋体'>对象做了部分开发。</span></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>b)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>框架层面</span><span lang=EN-US>ExtJs</span><span
style='font-family:宋体'>的可解耦性</span></h2>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>WLJ</span><span style='font-family:宋体'>框架的发展，到目前为止的主要总结是：面向句柄的开发模式。而要做到这一点，主要的两个方面，包括：</span><span
lang=EN-US>1</span><span style='font-family:宋体'>、框架要提供运行环境，运行效果由框架执行，使代码静态化；</span><span
lang=EN-US>2</span><span style='font-family:宋体'>、稳定、固化业务抽象的独立的开发句柄对象。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>通过以上的两点，基本上框架可以做到业务技术分离；框架的版本滚动更新；</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>框架逐步解耦；通过对底层的修改，支持多种平台。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>那么，</span><span lang=EN-US>ExtJs</span><span
style='font-family:宋体'>作为其底层支持的库，有多大的可解耦性。这是详细逐步分析的。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.3pt'><strong><span
lang=EN-US style='font-family:"Calibri","sans-serif"'>1</span></strong><strong><span
style='font-family:宋体'>、吸收：</span></strong><span style='font-family:宋体'>对于</span><span
lang=EN-US>ExtJs</span><span style='font-family:宋体'>框架的部分比较优秀，运用比较的频繁的</span><span
lang=EN-US>API</span><span style='font-family:宋体'>，或者机制应该吸收进</span><span
lang=EN-US>WLJ</span><span style='font-family:宋体'>框架的底层；如：</span><span
lang=EN-US>Ext.ns</span><span style='font-family:宋体'>（命名空间定义），</span><span
lang=EN-US>Ext.extend</span><span style='font-family:宋体'>（对象继承机制），</span><span
lang=EN-US>Ext.util.MixedCollection</span><span style='font-family:宋体'>（集合数据结构），</span><span
lang=EN-US>Observable</span><span style='font-family:宋体'>（基于观察模式的基础对象），部分</span><span
lang=EN-US>JS</span><span style='font-family:宋体'>与源生对象的增强，部分</span><span
lang=EN-US>DOM</span><span style='font-family:宋体'>的增强等等。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.3pt'><strong><span
lang=EN-US style='font-family:"Calibri","sans-serif"'>2</span></strong><strong><span
style='font-family:宋体'>、抽象父类：</span></strong><span style='font-family:宋体'>目前框架主要的组件，大都是从</span><span
lang=EN-US>Ext</span><span style='font-family:宋体'>的组件继承派生出来的。这里应该逐步将父类抽象化，形成一套类似适配器的父类派生系统。逐步将当前的框架版本变成抽象父类的一个</span><span
lang=EN-US>Ext</span><span style='font-family:宋体'>版本的实现。之后，我们的自己编写底层支持库，或者更换其他的</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>支持库，将会有一个实现标准。如：列表、表单、树形面板、窗口、普通面板的基础</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>对象的抽象类；</span><span
lang=EN-US>Ajax</span><span style='font-family:宋体'>对象、数据源对象等的向上抽象；动画特效、拖动功能对象的抽象；事件系统的抽象；等等。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.3pt'><strong><span
lang=EN-US style='font-family:"Calibri","sans-serif"'>3</span></strong><strong><span
style='font-family:宋体'>、子系统的替换实现：</span></strong><span style='font-family:宋体'>如插件系统、设计、控制台等系统的实现要适配新版本的支持库。子系统的抽象，可以以接口的形式抽象，且实现工作可以靠后，不影响主体功能的运行。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.3pt'><strong><span
lang=EN-US style='font-family:"Calibri","sans-serif"'>4</span></strong><strong><span
style='font-family:宋体'>、样式资源文件系统：</span></strong><span style='font-family:宋体'>如果替换新的支持库，如果该支持库是自带</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>组件的，则需要研究拆分其样式资源体系，尽量做到符合当前的样式体系标准。对于涉及到内部事件判断的样式，必须与现有样式体系保持一致。</span></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>c)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>开发过程中，对于</span><span lang=EN-US>EXT</span><span
style='font-family:宋体'>基础对象的替换或者剥离</span></h2>

<p class=TIP style='margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-family:Wingdings;font-style:normal'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:宋体'>跑东方资产的收获</span></p>

<p class=TIP><span style='font-family:宋体'>前两周跑了东方资产两次，项目上有个业务功能极其复杂。功能的代码，加上引用的</span><span
lang=EN-US>js</span><span style='font-family:宋体'>代码，行数上几乎是</span><span
lang=EN-US>WLJ</span><span style='font-family:宋体'>框架代码总量的数倍，这应该是需求设计的问题。</span></p>

<p class=TIP><span style='font-family:宋体'>该功能中，有颇多地方需要实现表单、列表的动态嵌套使用。原本，框架并不提供这种功能的解决。因为</span><span
lang=EN-US>WLJ</span><span style='font-family:宋体'>框架提供运行环境和句柄，但不提供类库，因为</span><span
lang=EN-US>Ext</span><span style='font-family:宋体'>的组件库已经非常丰富了。</span></p>

<p class=TIP><span style='font-family:宋体'>但是，在编写构建这些面板</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>的时候，开发人员并不使用</span><span lang=EN-US>Ext</span><span
style='font-family:宋体'>源生组件，转而使用了</span><span lang=EN-US>WLJ</span><span
style='font-family:宋体'>框架内的私有组件。因为该组件提供了默认的排版、构建、以及一些按钮的默认功能等，编写要方便的多。由于该组件是有上下文关系的，所以在运行的时候出问题了。这边，我安排人，编写了几个类，基本上调用参数不变，但是，排除掉了上下文的影响。</span></p>

<p class=TIP><span style='font-family:宋体'>可是，我在做这些的时候犹豫了。单纯的提供组件，是有悖于</span><span
lang=EN-US>WLJ</span><span style='font-family:宋体'>框架理念的。现在大部分的</span><span
lang=EN-US>JS</span><span style='font-family:宋体'>框架，只负责类库，不管理句柄；同时，对象都是直接调用，每一个对象都要有一个句柄去定位。这样，业务代码复杂，冗余，易出错。这是目前绝大多数开源</span><span
lang=EN-US>js</span><span style='font-family:宋体'>框架的问题。</span></p>

<p class=TIP><span style='font-family:宋体'>所以，特意增加了预加载开发句柄和构建</span><span
lang=EN-US>API</span><span style='font-family:宋体'>。这些对象的创建、检索，和移除，都使用</span><span
lang=EN-US>API</span><span style='font-family:宋体'>，不使用句柄，以此来保证这些对象都受框架控制。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>开发过程中，面对复杂的功能点，很多时候，开发人员不得不选择源生组件库来满足一些个性化的复杂的体验要求。然而，我们的框架做的事情并不提供组件库。所以，在之前的很多时候面对这些需求的时候，我也只能无奈的建议开发人员使用源生组件。倒不是我懒于添加一些组件，而是一旦提供组件库，开发人员可以任意创建组件，必然导致句柄膨胀，且句柄不可管理。这与我们的框架理念背道而驰。</span></p>

<p class=TIP style='margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-family:Wingdings;font-style:normal'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:宋体'>关于句柄膨胀和句柄的不可管理</span></p>

<p class=TIP><span style='font-family:宋体'>任何一个系统，都应该是一个输入输出功能的有限集合。面向句柄编程的思路，最为关键的部分，就是句柄。句柄的膨胀会大大增加句柄冲突的可能性；句柄的不可管理，则隐患更大。如果，业务代码中，大量出现不可管理的对象句柄，那么框架的可控范围就大大减小的。很多对象的生命周期无法管理；版本滚动更新时，还得避免这些不可管理句柄的雷区；尤其，如果我们的框架需要更新、更换一个底层的</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>库，或者更换一个平台执行的时候，这些句柄对象，就成为了拦路虎。一来，新的句柄接口必须跳过这些地雷；二来，我们的不得不为了这些不可控的句柄对象引入，或者编写与之对应的组建库，这是一个庞大的工程。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>所幸，东方资产运用的思路是我认为颇为有效的一个思路。既可以提供一系列的个性组件，又不至于让句柄膨胀，不可管理。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>总结一下，方案大致如下：</span></p>

<p class=MsoListParagraph style='margin-left:117.75pt;text-indent:-33.75pt'><span
lang=EN-US>1、<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>我们构建不同的个性</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>组件，但不提供直接创建的入口；</span></p>

<p class=MsoListParagraph style='margin-left:117.75pt;text-indent:-33.75pt'><span
lang=EN-US>2、<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>在全局</span><span lang=EN-US>API</span><span
style='font-family:宋体'>中，提供对这些组件的构建，检索，以及移除销毁的方法。虽然这种方法也有可能会产生多余句柄，但是，这些对象的生命周期完全受控于框架，这个句柄的存在与否，就不会成为太大的隐患。</span></p>

<p class=MsoNormal style='margin-left:42.55pt;text-indent:21.25pt'><span
style='font-family:宋体'>这个大致的方案，应该在接下来的更新中，逐步在产品研发和项目组的开发使用中推广。让一线开发人员不再使用源生的这些组件对象，而是使用</span><span
lang=EN-US>API</span><span style='font-family:宋体'>。这样，未来的如果更换平台，或者支持库，对于这些内部组件的适配，就与框架内部受控对象的适配方案一致。</span></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>d)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>不得不加的一节</span></h2>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>锦哥周三下午一通电话，我在这两天的大风里凌乱得不要不要的。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>作为一套开发框架，</span><span lang=EN-US>WLJ</span><span
style='font-family:宋体'>框架想要做的，只是在底层的</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>支持库之上，与开发人员的业务代码之间，构建一套无差异的开发运行环境。它可以适配各种底层的</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>框架，也可以去适配</span><span
lang=EN-US>PC</span><span style='font-family:宋体'>或者移动浏览器，或者移动</span><span
lang=EN-US>APP</span><span style='font-family:宋体'>；寄希望于保持开发接口的稳定，来让框架品屏蔽底层支持的不同，以及版本更新对业务代码的影响，甚或而能够统一代码，让同一篇代码在各种平台上，跑出相应的效果。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>要总结一下有可能的替换底层平台的需要的思路，其实大体上的思路就是我们在</span><span
lang=EN-US>ExtJs</span><span style='font-family:宋体'>的解耦性那一节中提到的，解耦的过程。一旦框架的底层边界（抽象父类）确定，就是可以按照固定的标准来进行实现。</span></p>

<p class=MsoListParagraph style='margin-left:81.75pt;text-indent:-18.0pt'><span
lang=EN-US>1、</span><span style='font-family:宋体'>实现所有的必要的抽象父类；</span></p>

<p class=MsoListParagraph style='margin-left:81.75pt;text-indent:-18.0pt'><span
lang=EN-US>2、</span><span style='font-family:宋体'>对开发接口的支持，要覆盖到所有的句柄和</span><span
lang=EN-US>API</span><span style='font-family:宋体'>。</span></p>

<h1 style='margin-left:28.1pt;text-indent:-28.1pt'><span lang=EN-US>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>一些观点</span></h1>

<h2><span lang=EN-US>a)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>架构</span></h2>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>架构是一个很有趣的概念。因为大家做软件越来越复杂，发现更建筑学很像，就借了这个概念。于是，也就出现架构师这个说法。算是职位？算是称呼？我不很懂。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>首先，我先申述一个观点。架构师和开发者只是分工不同而已，不存在谁比谁更应该有优越感。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>架构的概念最早是建筑学的，那建筑学的定义就不说了。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>软件领域的架构，也有很多的定义。听到过的一个最高深也最高大上的定义是：架构，就是把不同的东西分开来摆放。怎样，听起来牛逼吧。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>那是一个非常资深的架构师的定义，我还不能真正体会这句话的高深含义。但也颇有些自己的体会。我虽然不能直击核心地给出如此精彩的定义，但也能从浅一些的层面或者侧面来给出一个我的定义。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>架构，是带着严重的个人哲学理念的一套规则或者规范。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>架构最核心的难点在于取舍。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>所以，架构师最重要的品质也在于怎样面对取舍，或者说妥协，对于妥协两面的思考。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>架构师嘛，好多人都可以这么叫。从通俗上的架构师定义来看，架构师也可以分为写框架的架构师和用框架的架构师。</span></p>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>核心意义上的架构一定是包含着技术成分也业务成分的。这两块很难分开，也很难区分。所以，很多时候啊，不要太过迷信有些主营业务不是</span><span
lang=EN-US>IT</span><span style='font-family:宋体'>服务的公司所开源出来的产品。他们开源出来的产品很可能阉割掉了最核心的技术，或者至少做了业务脱敏。那么，我们所真正能够看到的，也只是比较皮毛的东西了。</span></p>

<h2><span lang=EN-US>b)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>框架发展与含义：从</span><span lang=EN-US>main</span><span
style='font-family:宋体'>函数开始，逐步形成框架与产品</span></h2>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>何为框架。我要写的东西有点执著。见谅。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>从</span><span lang=EN-US>JAVA</span><span
style='font-family:宋体'>谈起。对于我们这些只是使用语言，而不开发语言的人员来说，绝大多数情况都是从</span><span
lang=EN-US>main</span><span style='font-family:宋体'>函数开始。这不仅仅是说我们的学习经历，还包括了设计理念、框架等的发展历程，也是程序运行的过程。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>最初的框架，就是</span><span lang=EN-US>JVM</span><span
style='font-family:宋体'>。它负责运行，你负责写</span><span lang=EN-US>main</span><span
style='font-family:宋体'>函数中的逻辑片段。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>后来分化出</span><span lang=EN-US>SE</span><span
style='font-family:宋体'>和</span><span lang=EN-US>EE</span><span
style='font-family:宋体'>（</span><span lang=EN-US>ME</span><span
style='font-family:宋体'>不聊，聊起来有点崇洋媚外）。</span><span lang=EN-US>SE</span><span
style='font-family:宋体'>做桌面程序，败的一塌糊涂；</span><span lang=EN-US>EE</span><span
style='font-family:宋体'>做</span><span lang=EN-US>WEB</span><span
style='font-family:宋体'>以及网络，非常成功。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>SE</span><span style='font-family:宋体'>做逻辑，但也需要做</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>界面，后来出现</span><span
lang=EN-US>AWT</span><span style='font-family:宋体'>、</span><span lang=EN-US>SWT</span><span
style='font-family:宋体'>、</span><span lang=EN-US>SWING</span><span
style='font-family:宋体'>之类的组件库，但还是一塌糊涂。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>EE</span><span style='font-family:宋体'>做网络程序；这里它们首先提出了自己的</span><span
lang=EN-US>main</span><span style='font-family:宋体'>函数，就是</span><span
lang=EN-US>severlet</span><span style='font-family:宋体'>接口，开发就是补充</span><span
lang=EN-US>severlet</span><span style='font-family:宋体'>里的逻辑片段；在这个方向上，又出现了</span><span
lang=EN-US>Struts</span><span style='font-family:宋体'>之流，它们把这个</span><span
lang=EN-US>main</span><span style='font-family:宋体'>函数丰满起来，让开发人员写的片段更少了。当然，这里还有一个关键，在于</span><span
lang=EN-US>UI</span><span style='font-family:宋体'>这块，让</span><span lang=EN-US>HTML</span><span
style='font-family:宋体'>，或者说浏览器去做了，这让</span><span lang=EN-US>EE</span><span
style='font-family:宋体'>这块的</span><span lang=EN-US>main</span><span
style='font-family:宋体'>函数写起来容易多了。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>单纯从框架这一块来聊一聊区别或者说成败。</span><span lang=EN-US>SE</span><span
style='font-family:宋体'>给你提供了组件库，让你组织整体</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>；</span><span lang=EN-US>EE</span><span
style='font-family:宋体'>这个方向，给你做好了整体，让你填写其中一部分。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>一个让你造句；一个让你填空。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>当然，还有另外一个问题，就是</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>（或者精确点说，是界面）这部分内容。界面太具体了，所以，抽象起来很难；还有一个点，界面是客户可以直接看到的。他们可以说三道四，指指点点，或者投入自己的想法。于是，想法越来越多，越来越混乱，新的要求和需求几乎每天都有。它们是如此的灵活，如此的“不合理”。架构师们不得不以组件的方式提供</span><span
lang=EN-US>API</span><span style='font-family:宋体'>，把整体的设计交给能够直接接触需求的一线开发人员。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>因为，没有取舍。这样的取舍太难了。取舍出了问题，不仅仅会被客户骂，还会被开发人员骂（内部都不团结咯）。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>纵观</span><span lang=EN-US>JAVA</span><span
style='font-family:宋体'>历史上，各种号称框架的程序，其发展应用广泛与否，大部分是由我们的一线开发人员的开发体验决定的。他们用键盘投票，决定这些框架的生与死。（当然，运营支撑团队自身出现问题的原因除外。）而，生的这些框架，又大都是填空类型的，不是造句类型的。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>不知道这样的总结对不对。但是我还是觉得，弄填空类型的东西，好一点。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>我们现在聊的前端框架，就面临着</span><span lang=EN-US>SE</span><span
style='font-family:宋体'>的问题。用户对界面的</span><span lang=EN-US>UI</span><span
style='font-family:宋体'>体验要求越来越高，我们不得不在前端做大量的逻辑运算，尤其现在日益流行的移动前端。前端个性化逻辑的大量出现，就得有能支持逻辑的前端框架。</span></p>

<p class=MsoNormal style='margin-left:42.5pt;text-indent:21.25pt'><span
style='font-family:宋体'>那么，我们做前端框架应该怎么玩？</span></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>c)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>框架来执行，代码静态化。</span></h2>

<p class=MsoNormal style='margin-left:21.25pt;text-indent:21.25pt'><span
style='font-family:宋体'>句柄化的框架代码，业务逻辑逐渐静态化，尤其是脚本语言的静态化天性；静态化的代码更容易格式化、文档化。</span></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>d)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>静态代码通过不同的解释运行机制，形成不同的产品效果，包括不同版本，或者在不同平台下运行。</span></h2>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>e)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>基于句柄化的业务抽象可以有效地隔离业务需求与技术实现（提供环境，管理句柄）</span></h2>

<p class=TIP style='margin-left:91.65pt;text-indent:-21.0pt'><span lang=EN-US
style='font-family:Wingdings;font-style:normal'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:宋体'>先例</span></p>

<p class=TIP><span style='font-family:宋体'>早前有一个版本的绩效产品，采用了</span><span
lang=EN-US>Ext2.2</span><span style='font-family:宋体'>做为前端框架开发。在该产品的前端代码中，做了一些简单的布局句柄，比如东南西北的面板的句柄。但是，可惜，该版本的产品做得不很彻底，也并不强制。该产品的代码有一些句柄化框架的小思路了，但是并没有人去真正做一个框架出来。从业务中抽象句柄，并独立形成可生长的句柄系统；当然，还有更为根本的缺陷，就是约定的几个句柄，仅仅是简单地教给</span><span
lang=EN-US>Ext</span><span style='font-family:宋体'>框架去执行，并没有提供完善的运行环境。</span></p>

<h2 style='margin-left:26.35pt;text-indent:-26.35pt'><span lang=EN-US>f)<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>自运行框架在自动化、测试、监控方向上都可以很好的支持</span></h2>

<h1><span lang=EN-US>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>附：</span></h1>

<h2><span lang=EN-US>a)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>接口文件（</span><span lang=EN-US>API</span><span
style='font-family:宋体'>、</span><span lang=EN-US>HEADER</span><span
style='font-family:宋体'>）</span></h2>

<p class=MsoNormal><span lang=EN-US><img width=180 height=56
src="WLJ前端框架的介绍与思考.files/image001.png"><img width=208 height=56
src="WLJ前端框架的介绍与思考.files/image002.png"></span></p>

<h2><span lang=EN-US>b)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>配置及补丁文件</span><span lang=EN-US>(CFG</span><span
style='font-family:宋体'>、</span><span lang=EN-US>DEFAULTPATEH</span><span
style='font-family:宋体'>、</span><span lang=EN-US>SYSTEMPATCH)</span></h2>

<p class=MsoNormal><span lang=EN-US><img width=215 height=56
src="WLJ前端框架的介绍与思考.files/image003.png"><img width=121 height=56
src="WLJ前端框架的介绍与思考.files/image004.png"><img width=105 height=56
src="WLJ前端框架的介绍与思考.files/image005.png"></span></p>

<h2><span lang=EN-US>c)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>运行支撑文件</span><span lang=EN-US>(APP</span><span
style='font-family:宋体'>、</span><span lang=EN-US>BUILDER</span><span
style='font-family:宋体'>、</span><span lang=EN-US>BOOTER)</span></h2>

<p class=MsoNormal><span lang=EN-US><img width=186 height=56
src="WLJ前端框架的介绍与思考.files/image006.png"><img width=208 height=56
src="WLJ前端框架的介绍与思考.files/image007.png"><img width=148 height=56
src="WLJ前端框架的介绍与思考.files/image008.png"></span></p>

<h2><span lang=EN-US>d)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:宋体'>私有组建库</span></h2>

<p class=MsoNormal><span lang=EN-US><img width=321 height=56
src="WLJ前端框架的介绍与思考.files/image009.png"><img width=363 height=56
src="WLJ前端框架的介绍与思考.files/image010.png"><img width=368 height=56
src="WLJ前端框架的介绍与思考.files/image011.png"><img width=330 height=56
src="WLJ前端框架的介绍与思考.files/image012.png"><img width=348 height=56
src="WLJ前端框架的介绍与思考.files/image013.png"><img width=283 height=56
src="WLJ前端框架的介绍与思考.files/image014.png"></span></p>

</div>

</body>

</html>
