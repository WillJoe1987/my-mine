	7月16日，生产服务器预警，具体表现为：CPU使用率一段时间内持续能偏高，内存使用率一段时间内持续性偏高。从当时的日志情况来看，现实抛出内存不足（OutOfMemoryException）异常；jdk创建core、trc、和hpd等内存快照文件，并大量记录日志，此时由于磁盘空间不足，抛出系统异常。
系统环境：
1、操作系统：
	Linux version 2.6.18-308.el5 (mockbuild@x86-007.build.bos.redhat.com) (gcc version 4.1.2 20080704 (Red Hat 4.1.2-50)) #1 SMP Fri Jan 27 17:17:51 EST 2012
16G内存
2、WebSphere：
	名称                       IBM WebSphere Application Server - ND
	版本                       7.0.0.29
	标识                       ND
	构建级别                     cf291321.01
	构建日期                     5/26/13
	体系结构                     AMD (64 bit)
3、JDK:
	java version "1.6.0"
	Java(TM) SE Runtime Environment (build pxa6460sr13fp2-20130424_01(SR13 FP2))
	IBM J9 VM (build 2.4, JRE 1.6.0 IBM J9 2.4 Linux amd64-64 jvmxa6460sr13fp2-20130423_146146 (JIT enabled, AOT enabled)
	J9VM - 20130423_146146
	JIT  - r9_20130108_31100ifx1
	GC   - 20121212_AA)
	JCL  - 20130419_01
4、部署情况：
	两台物理机器节点；
	每台物理节点上分为两个逻辑节点，
	每个节点上启动一个web服务器，每个服务分配2-8G内存空间
5、主要服务器启动参数： 
	-Djava.home=/opt/IBM/WebSphere/AppServer/java/jre（java虚拟机路径） 
	-Xdump （内存出现崩溃时，生成快照）
	-verbose:gc  （打开GC日志）
	-Xms2000m  （JVM最小堆内存）
	-Xmx8000m   （JVM最大堆内存）
原因分析：
	1、OOM（OutOfMemoryException）抛出，是由于操作系统内存耗尽，无法为jvm提供相应内存导致，并非虚拟机本身溢出导致。
从当时的OOM异常日志来看，这个异常是由native lib抛出。说明，此次内存空间不足，是由于系统内存耗空，java虚拟无法从操作系统获取新的内存导致。并不是栈溢出（overflow stack），堆溢出（heap space）或者非堆栈内存区域空间不足（permSize）产生。所以，这个OOM异常的出现，并不是由于JAVA程序本省产生的。
	2、websphere生成转存储文件后，依然无法正常工作，是由于磁盘空间耗尽，无法记录日志导致。
OOM之后，日志中出现“设备空间不足”的异常，应该是由于生成转存储文件口，磁盘空间耗空。
	3、抛出异常前JVM内存暴增，是由于单次查询的数据量过大。
从当时的转存储文件分析结果，发现，当时的内存空间中，IndexedCollection类只有19个实例，却占据了5G+的内存。（IndexedCollection类是系统框架中，专门用于保存SQL查询结果）说明一定存在SQL单次查询出大量数据放在内存中的情况。
分析结果：
	1、web服务器内存配置需要优化
操作系统共16G物理内存。这些内存要负担操作系统、系统服务，websphere节点（node）、控制台的内存消耗，并不足以为每个web服务器提供最大8G的堆内存，同时还要负担非堆内存，所以这里存在潜在的内存出现不够用的情况，导致出现OOM的情况。
	2、磁盘空间预留不足
防止磁盘空间不足的情况，可以取消DUMP文件生成，注意日志文件的清除，或者适当增加磁盘空间；
	3、内存回收正常，框架运行稳定
 
途中显示出10点钟左右，有大量交易出现，但交易结束后，均能够回归稳定，10：30分之后，呈现稳定的锯齿形，说明JDK的内存回收轮询程序正常工作，且稳定

	4、账号查询业务逻辑未分页，遇到账号数量上万的，即造成JVM内存暴增。
通过对业务逻辑代码、以及业务数据的排查，账号查询未进行分页，且最大可能存在一次性展示30W+数据的情况。这种情况下，这30W+数据需要暂存在内存中，同时还需要在热编译为html代码，就可能会使最大内存空间（8G）都消耗殆尽。这个过程中jvm会进行大量的内存回收动作导致业务逻辑不断暂停，处理缓慢；同时如果有新的请求到来，就会形成排队，同时回收内存，最终形成恶性循环。（所以会出现CPU使用率居高不下的情况。）
测试服务器中，经过测试，在单个客户有20W+的数据时，效果见附四。暂未测试出临界值。执行GC后，内存基本都可以回收，但峰值期间，执行22次java类卸载操作；执行GC操作30次，GC耗时将近2分钟。同时，浏览器端在同时要展示1W+的数据时，浏览器进程已经卡死，无法展示。
优化建议：
	1、	web服务器启动参数调整为：-Xms2000m –Xmx6000m(参考值)
通过对系统在空负载的情况，内存最低点为100M左右，内存波动均在1G以内；并发情况下，内存波动范围也仅在2G-5G范围内；所以，可将web服务最大内（-Xmx）存调低至：6000M（预留一定弹性空间），最小内存（-Xms）调低至 2G；
本系统中，JAVA进程的非堆内存稳定在160M左右，这部分内存不包含在-Xmx的限制之内。所以，单个web服务器的-Xmx的最大值，至多可以设置为：（（16G-操作系统消耗的内存-系统服务消耗的内存-两个node进程的内存消耗）/2 ）-200M（预留40M的非堆内存）。
一般看系统并发状况，按需配置即可（方法参见附3）。
	2、列表查询添加分页逻辑
对于列表查询业务，一定要严格考证查询结果集的大小，尽量使用使用分页查询的方式。（本次出现生产事故是由于根据客户号查询客户账户信息时，出现了单个客户的账号量上万的情况，而没有进行分页处理，已在系统中追加了分页逻辑）。
附一：JVM内存模型简述
	IBM的web服务器实用IBM自提供的JDK，使用J9虚拟机。
该虚拟机总内存由堆内存和非堆内存组成；其中，非堆内存中，存储了包括加载的类型对象（class）、即时编译（JIT）所需的临时内存；而堆内存中包含了所有实例对象，即代码运行过程中所有new或者反射的出的对象实例。
堆内存由-Xmx和-Xms参数控制（默认为1/4的系统内存）；
非堆内存在IBM的jdk中，有虚拟机自行调整；在sun jdk1.6以下由-XX：permSize和-XX：MaxPermSize参数控制，1.7以上则由虚拟机自行调整，但这一部分内存并不包含堆内存中（即-Xmx）所指定的大小。
Java进程消耗的总的系统内存一般大于等于这两者之和。
附二：WEB服务器JVM内存分配和垃圾回收机制简述
	J9虚拟机中，取消了HOTSPOT虚拟中的永久带（permSpace），拆分在非堆内存中，由虚拟机自动控制大小。
非堆内存：java虚拟机在需要的时候，所读取的所有类对象，都存储在这个空间中；另外，当某一段代码调用特别频繁的时候，虚拟机就会启动即时编译器（JIT）对代码进行进一步编译为可以直接执行的机器代码，以保证运行效率，这部分机器代码也保存在非堆内存中。
这一部分内存对于开发人员而言，是透明的，并且不会影响程序效率。
堆内存：堆内存中，存储了JVM运行过程中，构建的实例对象，包括new和反射的对象。开发人员的代码所操作的对象，全部在这一部分存储。这一部分的使用情况，将直接影响到程序运行的效率。
堆内存中，又分为新生代和老年代。其中，老年代一般用于存放永久性存在的对象（如：static类型的常量等）、经过多次内存回收依然存在的对象，以及消耗内存过大的对象。而新生代，则一般用于存储新创建的对象，大部分是即生即灭的对象（如方法体中的中间变量等）。当新构建的对象过大，超过一定阀值时，会直接在老年代创建；当新生代中的对象经过多次内存回收依然存在时，就会被移动到老年代。

Java的垃圾回收机制（GC），是java保证代码要求宽松，同时又能高效稳定运行这一对矛盾的基础。它的回收算法，触发机制在不同的运行环境、业务场景下，可能会由很多不同的版本和实现。这里简要说一下Web服务器一般采用的策略。
JVM在进行垃圾回收的时候，会停止掉所有正在运行的线程，等待垃圾回收。
垃圾回收一般分为全量的回收和部分回收。全量回收会扫描整个堆内存，回收所有的无用对象；部分回收择只回收新生代对象。全量回收一般消耗较大，可能持续到数秒到数十秒。
WEB服务器中，一般会尽可能地减少GC，以提高服务器性能。WEB服务器中，GC的触发一般分为两种。
当内存不足时，会优先进行部分GC；当部分GC处理后，内存依然不足时，才有可能触发全量GC。此时，会中断所有线程，回收无用对象，将新生代中符合条件的对象移动到老年代。当GC后内存依然不足时，就会抛出OutOfMemoryException。堆内存不足时，是触发GC，还是向操作系统申请新的内存，在JVM中策略比较复杂，这里不做描述。
WEB服务器同时会有一个守护线程，以轮询的方式，每隔一段时间进行一次内存的回收动作。其中IBM的J9虚拟机，轮询周期为1小时。所以，JVM内存上扬之后，如果没有新的请求触发GC，java的内存消耗并不会立刻回收。

虚拟机中在老年代创建对象开销较大，GC操作，尤其是全量GC消耗更大。所以，在代码编写中，要进行避免创建大对象（比如一个很长的字符串，或者需要大量拼接的SQL语句，可以实用StringBuffer对象，而不要使用String对象）。

附三：WEBSPHERE内存参数调整的的一些方法
	对于标准安装的IBM Websphere Application Server中，一般都会采用的自带的IBM的java虚拟机。一般在$WEBSPHERE_HOME/AppServer/java目录下。其中，/jre目录下，提供了最简运行环境，服务启动时，JAVA_HOME环境变量就指向该目录。/bin目录下，提供了部分部分操作、监控的工具。

/bin目录下，IBM提供了jconsole工具，该工具可以连接到当前正在运行的java虚拟机，并显示该虚拟机的实时状态。也可以实用的sun的jvisualvm或者jconsole工具远程连接监控。
如要远程监控，择需要打开该虚拟机的远程监控功能，在/jre/lib/management/management.properties文件中，修改如下配置：
	com.sun.management.jmxremote.port=8999
 	com.sun.management.jmxremote.authenticate=false
 	com.sun.management.jmxremote.ssl=false
择远程监控端口被置为：8999，
